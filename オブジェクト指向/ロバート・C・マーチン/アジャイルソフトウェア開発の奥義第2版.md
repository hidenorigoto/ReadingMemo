ロバート・C・マーチン『アジャイルソフトウェア開発の奥義』第2版
==============================================================

# 基本情報

- 書籍名: アジャイルソフトウェア開発の奥義（第2版）
- 出版社: ソフトバンク・クリエイティブ
- 出版年: 2008年
− ISBN: 4-7973-4778-4

----

# メモ

## 第7章 アジャイル設計とは？

### p.108 （7.2 設計の悪臭 - 腐敗するソフトウェアの兆候）

> 書きに示した傾向が1つでも現れたら、ソフトウェアが腐敗し始めた兆候である。
> 
> 1. 硬さ -- 変更しにくいシステム。1つの変更によってシステムの他の部分に影響がおよび、多くの変更を余儀なくさせるようなソフトウェア
> 2. もろさ -- 1つの変更によって、その変更とは概念的に関連のない箇所まで壊れてしまうようなソフトウェア
> 3. 移植性のなさ -- 他のシステムでも再利用できる部分をモジュールとして切り離すことが困難なソフトウェア
> 4. 扱いにくさ -- 正しいことをするよりも、誤ったことをする方が容易なソフトウェア
> 5. 不必要な複雑さ -- 本質的な意味を持たない構造を内包しているようなソフトウェア
> 6. 不必要な繰り返し -- 同じような構造を繰り返し含み、抽象化してまとめられる部分がまとまっていないソフトウェア
> 7. 不透明さ -- 読みにくく、わかりにくい。その意図がうまく伝わってこないソフトウェア


## 第9章 オープン・クローズドの原則（OCP）

### p.128 （9.2 オープン・クローズドの原則（OCP）の概要）

> オープン・クローズドの原則（OCP）に従って設計されたモジュールには、次のような特徴的な2つの属性がある。
>
> 1. **拡張に対して開かれている（オープン：Open）**
>    これは、モジュールの振る舞いを拡張できるという意味である。アプリケーションの仕様要求が変更されても、モジュールに新たな振る舞いを追加することでその変更に対処できる。つまり、そのモジュールの処理内容を変更できるのだ。
> 2. **修正に対して閉じている（クローズド：Closed）**
>    モジュールの振る舞いを拡張しても、そのモジュールのソースコードやバイナリコードは全く影響を受けない。すでにモジュールがコンパイルされてバイナリ形式になっているものは、それがリンクライブラリであろうと、DLLであろうと、Javaの.jarファイルであろうと手を触れる必要はない。

### p.135,136 （9.4.4 「先を見越した構造」と「自然な構造」）

> このような仕様変更が起きることを先に見越していれば、その変更から身を守ることのできる「抽象」を導入できているはずだ。しかし、リスト9-2で使った抽象は、この種の変更に対しては助けになるどころか邪魔でしかない。つまり、この抽象は不適切だったということだ。この事実には驚くかもしれない。一体全体、SquareやCircleといった派生クラスのベースとして、基本クラスShape以上にふさわしいクラスなどあるのだろうか？ どうしてShapeが最も適切で自然なモデルではないのだろうか？ その答えは、図形の形よりも描画の順番の方が重要なシステムにおいては、Shapeを使ったモデルは自然**ではない**ということなのだ。
> これはショッキングな結論だろう。どんなに「閉じた（Closed）」モジュールであっても、閉じることのできない変更が必ずあるのだ。つまり、**すべてのケースに適用できる自然なモデルなど存在しないのだ！**
> あらゆる変更に対して完璧に閉じることが不可能なら、戦略的に閉じるしかない。つまり、設計する人がどういった種類の変更に対して自分の設計を閉じたいのかを選択する必要がある。設計担当者は、どういった種類の変更が頻繁に起こるのかを推測し、そういった変更から自分の身を守ることができるように「抽象」を構築するわけだ。

Open-Closedにした抽象の軸と異なる変更に対しては、当然Closedではいられない。ここでのシステムの問題領域は、「順序」という実装側からの要請をも含んだ領域まで拡大していて、そこも考慮して適切な抽象を選択する必要がある、という点には納得がいく。実装側の要請がないモデルだけでは、閉じるべき変更（可変性）の焦点を絞れないのは、明らかだ。

> これには経験に裏打ちされたある程度の洞察力が必要になる。経験豊かな設計者は、どういった種類の変更がどれくらいの確率で起きるのかを判断するために、ユーザーや業界のことを理解しておきたいと願っているものだ。そうすれば、最もありそうな変更に対してオープン・クローズドの原則（OCP）を使うことができるからだ。
> これは簡単なことではない。要するにそれは、アプリケーションがどんな種類の変更に長期間に渡って対応しなければならないのかを知的に判断することである。正しく推測できれば勝者で、間違った推測をすれば敗者だ。そしてほとんどの場合、その勘は外れるのである。
> また、OCPに準ずるという行為が高くつきすぎる場合もある。開発には時間がかかるし、適切な抽象を行うのにも努力が必要だ。それに、こういった抽象がソフトウェア設計をさらに複雑にしてしまう可能性もある。また、開発者が一度に扱うことができる抽象の量には限界があるので、OCPの適用は起こる可能性の高い変更に限定すべきなのは明らかだ。
> では、どうすれば発生しそうな変更を推測できるだろうか？ 適切なリサーチを行い、適切な質問を投げかけ、その上で経験と常識を使う。それ以外にできることは何もない。あとは**実際に変更が起きるのを待つしかない！**

